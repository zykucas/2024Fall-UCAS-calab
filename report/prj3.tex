\documentclass[12pt,a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[UTF8,heading=true]{ctex}
\usepackage{geometry}
\usepackage{diagbox}
\usepackage[]{float}
\usepackage{xeCJK}
\usepackage{indentfirst}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{listings}
\usepackage{xcolor}

% 设置代码块样式
\lstset{
  frame=tb,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  framerule=1pt,
  rulecolor=\color{gray!35},
  backgroundcolor=\color{gray!5},
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{green!50!black},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
}

\setCJKfamilyfont{zhsong}[AutoFakeBold = {5.6}]{STSong}
\newcommand*{\song}{\CJKfamily{zhsong}}

\geometry{a4paper,left=2cm,right=2cm,top=0.75cm,bottom=2.54cm}

\newcommand{\experiName}{prj3}%实验名称
\newcommand{\name}{28}
\newcommand{\student}{刘景平、张钰堃、付博宇}%姓名
\newcommand{\others}{$\square$}
\newcommand{\sectionfont}{\song\textbf}

\ctexset{
    section={
        format+=\raggedright
    },
    subsection={
        name={\quad,.}
    },
    subsubsection={
        name={\qquad,.}
    }
}

\begin{document}
\noindent

\begin{center}

    \textbf{\song \zihao{-2} \ziju{0.5} 计算机体系结构（研讨课）实验报告}
    
\end{center}


\begin{center}
    \kaishu \zihao{5}
    \noindent \emph{实验项目}\underline{\makebox[5em][c]{\experiName}}
    \emph{小组编号}\underline{\makebox[5em][c]{\name}} 
    \emph{组员姓名}\underline{\makebox[20em][c]{\student}}
    {\noindent}
    \rule[5pt]{17.7cm}{0.2em}

\end{center}


\section{\sectionfont 逻辑电路结构与仿真波形的截图及说明}
    \subsection{exp10}
        \subsubsection{添加算术指令}
            1.添加算术指令首先需要增加有关指令类型的译码信号，按照之前的格式，写明该指令的汇编代码和具体操作，以slti和sltui指令为例：
            \begin{lstlisting}[language=Verilog]
            //slti rd, rj, si12
            //rd = (signed(rj) < SignExtend(si12, 32)) ? 1 : 0
            assign inst_slti   = op_31_26_d[6'h00] & op_25_22_d[4'h8];
            //sltiu rd, rj, si12
            //rd = (unsigned(rj) < SignExtend(si12, 32)) ? 1 : 0
            assign inst_sltiu  = op_31_26_d[6'h00] & op_25_22_d[4'h9];
            \end{lstlisting}
            \par
            2.需要根据指令类型译码信号更改其他相关的译码信号，如gr—we、aluop等，剩余的指令通路与之前的算术指令相同。
            \par
            3.注意到andi，ori，xori指令的立即数扩展模式是零扩展，与之前的算术指令不同，需要单独处理。
            \begin{lstlisting}[language=Verilog]
              assign need_ui12  =  inst_andi | inst_ori | inst_xori;   //立即数扩展模式
              assign imm = src2_is_4 ? 32'h4                      :   
                        need_si20 ? {i20[19:0], 12'b0}         :   
                        need_ui5  ? {27'b0,rk[4:0]}            :   
                        need_si12 ? {{20{i12[11]}}, i12[11:0]} : 
                        need_ui12 ? {20'b0,i12[11:0]}         :   
                        32'b0 ;
            \end{lstlisting}
        
        \subsubsection{添加乘法指令}
            1.添加乘法指令首先需要增加有关指令类型的译码信号，思路同算术指令
            \begin{lstlisting}[language=Verilog]
                //mul.w rd, rj, rk
                //product = signed(GR[rj]) * signed(GR[rk])
                //GR[rd] = product[31:0]
                assign inst_mul_w  = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h1] & op_19_15_d[5'h18];
                //mulh.w rd, rj, rk
                //product = signed(GR[rj]) * signed(GR[rk])
                //GR[rd] = product[63:32]
                assign inst_mulh_w = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h1] & op_19_15_d[5'h19];
                //mulh.wu rd, rj, rk
                //product = unsigned(GR[rj]) * unsigned(GR[rk])
                //GR[rd] = product[63:32]
                assign inst_mulh_wu= op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h1] & op_19_15_d[5'h1a];
            \end{lstlisting}
            2.更改相关译码信号
            \par
            3.实现了一个乘法模块 mul，支持三种操作：普通乘法（mul.w）、高位乘法（mulh.w）和无符号高位乘法（mulh.wu）。
            \par
            根据输入的 mul_op 信号，模块决定如何处理输入的两个32位源操作数 mul_src1 和 mul_src2
            \par
            \begin{itemize}
                \item mul_src1 和 mul_src2 在执行高位乘法时会进行符号扩展，其他情况下则进行零扩展
                \begin{lstlisting}[language=Verilog]
                    // when executing mulh.w instruction, the operands should be sign-extended;
                    // otherwise, the operands should be zero-extended
                    assign mul_src1_ext = {op_mulh_w & mul_src1[31], mul_src1};
                    assign mul_src2_ext = {op_mulh_w & mul_src2[31], mul_src2};
                \end{lstlisting}
                \item 乘法结果是66位的，取低32位作为 mull_result，高32位作为 mulh_result（这里并没有挑战自己采用电路级实现乘法功能，而是直接调用IP）
                \begin{lstlisting}[language=Verilog]
                    // 66-bit signed multiply
                    wire signed [65:0] mul_res_66;
                    assign mul_res_66 = $signed(mul_src1_ext) * $signed(mul_src2_ext);
                    wire [31:0] mull_result;
                    wire [31:0] mulh_result;
                    // wire [31:0] mulh_wu_result;
                    assign mull_result = mul_res_66[31: 0];
                    assign mulh_result = mul_res_66[63:32];
                \end{lstlisting}
                \item 最后通过多路选择器根据操作类型输出最终结果 mul_result
                \begin{lstlisting}[language=Verilog]
                    assign mul_result = ({32{op_mul_w              }} & mull_result)
                    |                   ({32{op_mulh_w | op_mulh_wu}} & mulh_result);
                \end{lstlisting}

    \subsection{exp11}
        \subsubsection{添加转移指令}
          1.添加转移指令首先需要增加有关指令类型的译码信号，按照之前的格式，写明该指令的汇编代码和具体操作，以beq和bne指令为例：
          \par
          2.需要根据指令类型译码信号更改其他相关的译码信号，如gr—we、br-target等，剩余的指令通路与之前的转移指令相同。
          \par
          3.为了同时处理有符号数和无符号数的比较，需要利用加法进行判断，在ID模块中加入了一个小加法器。
          \begin{lstlisting}[language=Verilog]
            //imitation calcu slt and sltu in alu
          wire signed_rj_less_rkd;
          wire unsigned_rj_less_rkd;

          wire cin;
          assign cin = 1'b1;
          wire [31:0] adver_rkd_value;
          assign adver_rkd_value = ~rkd_value;
          wire [31:0] rj_rkd_adder_result;
          wire cout;
          assign {cout, rj_rkd_adder_result} = rj_value + adver_rkd_value + cin;

          assign signed_rj_less_rkd = (rj_value[31] & ~rkd_value[31])
                                        | ((rj_value[31] ~^ rkd_value[31]) & rj_rkd_adder_result[31]);
          assign unsigned_rj_less_rkd = ~cout;  
          \end{lstlisting}
          首先将rd中的值取反，然后将rj与~rd相加，并加入一个进位1，计算出一个33位的加法结果，其中最高位cout为进位。
          对于无符号数的比较而言，如果没有进位则说明rj小于rd，即unsigned\_rj\_less\_rkd为1。
          对于有符号数的比较而言，如果rj的符号为1，而rd的符号位为0，则可直接说明rj小于rd，即signed\_rj\_less\_rkd为1；
          如果rj和rd的符号位相同，则需要比较rj与~rd的加法结果的符号位，如果为1则说明rj小于rd，即signed\_rj\_less\_rkd为1。
        
        \subsubsection{添加st指令}
        在LoongArch指令集中st.b、st.h、st.w分别对应store byte（1字节）/halfword（2字节）/word（4字节），其中.h和.w分别要求地址2字节和4字节对齐。
        \par
        1.添加转移指令首先需要增加有关指令类型的译码信号,不再次举例
        \par
        2.st.b的四种偏移00、01、10、11分别对应mem_we为0001、0010、0100、1000。st.h的两种偏移00、10分别对应mem_we为0011、1100。如此对mem_we进行赋值。32位的wdata将8位数据重复4次，16位数据重复2次填满即可
        \par
        3.在EX中对未对齐的地址进行对齐操作，定义了一个写使能信号 w_strb 和真实写数据 real_wdata，根据 st_op 的不同情况进行选择
        \begin{lstlisting}[language=Verilog]
            wire [3:0] w_strb;  //depend on st_op
            assign w_strb =  es_st_op[0] ? 4'b1111 :
                             es_st_op[1] ? (es_unaligned_addr==2'b00 ? 4'b0001 : es_unaligned_addr==2'b01 ? 4'b0010 : 
                                            es_unaligned_addr==2'b10 ? 4'b0100 : 4'b1000) : 
                             es_st_op[2] ? (es_unaligned_addr[1] ? 4'b1100 : 4'b0011) : 4'b0000;
            wire [31:0] real_wdata;
            assign real_wdata = es_st_op[0] ? es_rkd_value :
                                es_st_op[1] ? {4{es_rkd_value[7:0]}} :
                                es_st_op[2] ? {2{es_rkd_value[15:0]}} : 32'b0;
        \end{lstlisting}
        4.对SRAM相关信号进行修改
        \begin{lstlisting}[language=Verilog]
            assign data_sram_en    = 1'b1;   
            assign data_sram_wen   = (es_mem_we && es_valid) ? w_strb : 4'b0000;
            assign data_sram_addr  = (es_mul_op != 0) ? {es_mul_result[31:2],2'b00} : {es_alu_result[31:2],2'b00};
            assign data_sram_wdata = real_wdata;   
        \end{lstlisting}



\section{\sectionfont 实验过程中遇到的问题、对问题的思考过程及解决方法}

\section{\sectionfont 实验分工}
    \subsection{exp10}
        张钰堃负责添加算术指令，刘景平负责添加除法指令，付博宇负责添加乘法指令。
    \subsection{exp11}
        张钰堃负责添加转移指令，刘景平负责添加load指令，付博宇负责添加store指令。
\end{document}